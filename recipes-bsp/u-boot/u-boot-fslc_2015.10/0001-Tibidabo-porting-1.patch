From 4e4e0080ec0eec0448dab12bd88e63f15fc6e797 Mon Sep 17 00:00:00 2001
From: fsessegoinfomob <fausto.sessego@infomob.it>
Date: Thu, 11 Feb 2016 11:23:34 +0100
Subject: [PATCH] Tibidabo porting 1

---
 board/architech/tibidabo/1066mhz_4x256mx16.cfg |  42 ++
 board/architech/tibidabo/Kconfig               |  12 +
 board/architech/tibidabo/MAINTAINERS           |   6 +
 board/architech/tibidabo/Makefile              |   9 +
 board/architech/tibidabo/README                |  92 +++++
 board/architech/tibidabo/clocks.cfg            |  41 ++
 board/architech/tibidabo/ddr-setup.cfg         |  96 +++++
 board/architech/tibidabo/tibidabo.c            | 545 +++++++++++++++++++++++++
 board/architech/tibidabo/tibidabo.cfg          |  46 +++
 configs/mx6qtibidabo_defconfig                 |   7 +
 10 files changed, 896 insertions(+)
 create mode 100644 board/architech/tibidabo/1066mhz_4x256mx16.cfg
 create mode 100644 board/architech/tibidabo/Kconfig
 create mode 100644 board/architech/tibidabo/MAINTAINERS
 create mode 100644 board/architech/tibidabo/Makefile
 create mode 100644 board/architech/tibidabo/README
 create mode 100644 board/architech/tibidabo/clocks.cfg
 create mode 100644 board/architech/tibidabo/ddr-setup.cfg
 create mode 100644 board/architech/tibidabo/tibidabo.c
 create mode 100644 board/architech/tibidabo/tibidabo.cfg
 create mode 100644 configs/mx6qtibidabo_defconfig

diff --git a/board/architech/tibidabo/1066mhz_4x256mx16.cfg b/board/architech/tibidabo/1066mhz_4x256mx16.cfg
new file mode 100644
index 0000000..1096f77
--- /dev/null
+++ b/board/architech/tibidabo/1066mhz_4x256mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E7974
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00428031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x19308030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42740304
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x026e0265
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x02750306
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02720244
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x463d4041
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x42413c47
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x37414441
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x4633473b
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0025001f
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x00290027
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x001f002b
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x000f0029
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/architech/tibidabo/Kconfig b/board/architech/tibidabo/Kconfig
new file mode 100644
index 0000000..b35f507
--- /dev/null
+++ b/board/architech/tibidabo/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_MX6TIBIDABO
+
+config SYS_BOARD
+	default "mx6tibidabo"
+
+config SYS_VENDOR
+	default "architech"
+
+config SYS_CONFIG_NAME
+	default "mx6tibidabo"
+
+endif
diff --git a/board/architech/tibidabo/MAINTAINERS b/board/architech/tibidabo/MAINTAINERS
new file mode 100644
index 0000000..888f214
--- /dev/null
+++ b/board/architech/tibidabo/MAINTAINERS
@@ -0,0 +1,6 @@
+TIBIDABO BOARD
+M:	Fausto Sessego <fausto.sessego@infomob.it>
+S:	Maintained
+F:	board/architech/tibidabo/
+F:	include/configs/tibidabo.h
+F:	configs/mx6qtibidabo_defconfig
diff --git a/board/architech/tibidabo/Makefile b/board/architech/tibidabo/Makefile
new file mode 100644
index 0000000..41b57c4
--- /dev/null
+++ b/board/architech/tibidabo/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6tibidabo.o
diff --git a/board/architech/tibidabo/README b/board/architech/tibidabo/README
new file mode 100644
index 0000000..9d84265
--- /dev/null
+++ b/board/architech/tibidabo/README
@@ -0,0 +1,92 @@
+U-Boot for the Boundary Devices Nitrogen6X and
+Freescale i.MX6Q SabreLite boards
+
+This file contains information for the port of
+U-Boot to the Boundary Devices Nitrogen6X and
+Freescale i.MX6Q SabreLite boards.
+
+1. Boot source, boot from SPI NOR
+---------------------------------
+The configuration in this directory supports both the
+Nitrogen6X and Freescale SabreLite board, but in a
+different fashion from Freescale's implementation in
+board/freescale/mx6qsabrelite.
+
+In particular, this image supports booting from SPI NOR
+and saving the environment to SPI NOR.
+
+It does not support 'boot from SD' at offset 0x400
+except through the 'bmode' command.
+	http://lists.denx.de/pipermail/u-boot/2012-August/131151.html
+
+2. Boots using 6x_bootscript on SATA or SD card
+-----------------------------------------------
+The default bootcmd for these boards is configured
+to look for and source a boot script named '6x_bootscript'
+in the root of the first partition of the following
+devices:
+
+	sata 0
+	mmc 0
+	mmc 1
+
+They're searched in the order listed above, trying both the
+ext2 and fat filesystems.
+
+2. Maintaining the SPI NOR
+--------------------------
+A couple of convenience commands
+
+	clearenv - clear environment to factory default
+	upgradeu - look and source a boot script named
+		'6x_upgrade' to upgrade the U-Boot version
+		in SPI NOR. The search is the same as for
+		6x_bootscript described above.
+
+3. Display support
+------------------
+U-Boot support for the following displays is configured by
+default:
+
+    HDMI           - 1024 x 768 for maximum compatibility
+    Hannstar-XGA   - 1024 x 768 LVDS (Freescale part number MCIMX-LVDS1)
+    wsvga-lvds     - 1024 x 600 LVDS (Boundary p/n Nit6X_1024x600)
+    wvga-rgb       - 800 x 480 RGB (Boundary p/n Nit6X_800x480)
+
+Since the ipuv3_fb display driver currently supports only a single display,
+this code auto-detects panel by probing the HDMI Phy for Hot Plug Detect
+or the I2C touch controller of the LVDS and RGB displays in the priority
+listed above.
+
+Setting 'panel' environment variable to one of the names above will
+override auto-detection and force activation of the specified panel.
+
+4. Building
+------------
+
+To build U-Boot for one of the Nitrogen6x or SabreLite board:
+
+	make nitrogen6x_config
+	make
+
+Note that 'nitrogen6x' is a placeholder. The complete list of supported
+board configurations is shown in the boards.cfg file:
+	nitrogen6q		i.MX6Q/6D	1GB
+	nitrogen6dl		i.MX6DL		1GB
+	nitrogen6s		i.MX6S		512MB
+	nitrogen6q2g    	i.MX6Q/6D	2GB
+	nitrogen6dl2g		i.MX6DL		2GB
+	nitrogen6s1g		i.MX6S		1GB
+
+The -6q variants support either the i.MX6Quad or i.MX6Dual processors
+and are configured for a 64-bit memory bus at 1066 MHz.
+
+The -6dl variants also use a 64-bit memory bus, operated at 800MHz.
+
+The -6s variants use a 32-bit memory bus at 800MHz.
+
+If you place the u-boot.imx into a single-partition SD card
+along with a binary version of the boot script 6x_upgrade.txt,
+you can program it using 'upgradeu':
+
+	U-Boot> run upgradeu
diff --git a/board/architech/tibidabo/clocks.cfg b/board/architech/tibidabo/clocks.cfg
new file mode 100644
index 0000000..8bddb91
--- /dev/null
+++ b/board/architech/tibidabo/clocks.cfg
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/* set the default clock gate to save power */
+DATA 4, CCM_CCGR0, 0x00C03F3F
+DATA 4, CCM_CCGR1, 0x0030FC03
+DATA 4, CCM_CCGR2, 0x0FFFC000
+DATA 4, CCM_CCGR3, 0x3FF00000
+DATA 4, CCM_CCGR4, 0x00FFF300
+DATA 4, CCM_CCGR5, 0x0F0000C3
+DATA 4, CCM_CCGR6, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
+DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4, CCM_CCOSR, 0x000000fb
diff --git a/board/architech/tibidabo/ddr-setup.cfg b/board/architech/tibidabo/ddr-setup.cfg
new file mode 100644
index 0000000..2748d40
--- /dev/null
+++ b/board/architech/tibidabo/ddr-setup.cfg
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/*
+ * DDR3 settings
+ * MX6Q    ddr is limited to 1066 Mhz	currently 1056 MHz(528 MHz clock),
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6DL   ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6SOLO ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 32 bits	x16/x32
+ */
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS4, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS5, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS6, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS7, 0x00000030
+
+DATA 4, MX6_IOM_GRP_B0DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B1DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B2DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B3DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B4DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B5DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B6DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B7DS, 0x00000030
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000030
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000030
+
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM4, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM5, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM6, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM7, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_CAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_RAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_1, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_RESET, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCKE0, 0x00003000
+DATA 4, MX6_IOM_DRAM_SDCKE1, 0x00003000
+
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00003030
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00003030
+
+/* (differential input) */
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+/* (differential input) */
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
+/* disable ddr pullups */
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000C0000
+
+/* Read data DQ Byte0-3 delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
+
+/*
+ * MDMISC	mirroring	interleaved (row/bank/col)
+ */
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00081740
+
+/*
+ * MDSCR	con_req
+ */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
diff --git a/board/architech/tibidabo/tibidabo.c b/board/architech/tibidabo/tibidabo.c
new file mode 100644
index 0000000..7caf511
--- /dev/null
+++ b/board/architech/tibidabo/tibidabo.c
@@ -0,0 +1,545 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ *
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6q_pins.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <malloc.h>
+#include <micrel.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <i2c.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/********************* uart *********************/
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |   \
+    PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |     \
+    PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t
+    const uart2_pads[]      =
+{
+    MX6_PAD_EIM_D26__UART2_TXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+    MX6_PAD_EIM_D27__UART2_RXD | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static void setup_iomux_uart(void)
+{
+    imx_iomux_v3_setup_multiple_pads(uart2_pads, ARRAY_SIZE(uart2_pads));
+}
+
+/********************* mmc *********************/
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |    \
+    PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |     \
+    PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t
+    const usdhc3_pads[]     = 
+{
+    MX6_PAD_SD3_CLK__USDHC3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_CMD__USDHC3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT0__USDHC3_DAT0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT1__USDHC3_DAT1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT2__USDHC3_DAT2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT3__USDHC3_DAT3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+    MX6_PAD_SD3_DAT5__GPIO_7_0    | MUX_PAD_CTRL(NO_PAD_CTRL),      /* CD */    
+};
+
+static struct fsl_esdhc_cfg
+    usdhc_cfg;
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+    struct fsl_esdhc_cfg
+        *cfg                = (struct fsl_esdhc_cfg *)mmc->priv;
+
+    if( cfg->esdhc_base == USDHC3_BASE_ADDR )
+    {
+        gpio_direction_input( IMX_GPIO_NR( 7, 0 ) );
+        return !gpio_get_value( IMX_GPIO_NR( 7, 0 ) );
+    }
+    else
+    {
+        return 1;
+    }
+}
+
+int board_mmc_init( bd_t *bis )
+{
+    usdhc_cfg.esdhc_base        = USDHC3_BASE_ADDR;
+    usdhc_cfg.sdhc_clk          = mxc_get_clock( MXC_ESDHC3_CLK );
+    usdhc_cfg.max_bus_width     = 4;
+    imx_iomux_v3_setup_multiple_pads( usdhc3_pads, ARRAY_SIZE(usdhc3_pads) );
+    return fsl_esdhc_initialize( bis, &usdhc_cfg );
+}
+
+/********************* spi flash *********************/
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |     \
+    PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+static iomux_v3_cfg_t
+    const ecspi1_pads[]         = 
+{
+    /* SS1 */
+    MX6_PAD_EIM_D19__GPIO_3_19   | MUX_PAD_CTRL(SPI_PAD_CTRL),
+    MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+    MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+    MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+};
+
+static void setup_spi(void)
+{
+    imx_iomux_v3_setup_multiple_pads( ecspi1_pads, ARRAY_SIZE( ecspi1_pads ) );
+}
+
+/********************* network *********************/
+
+#define ENET_PAD_CTRL       (PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t
+    const enet_pads1[]          =
+{
+    MX6_PAD_ENET_MDIO__ENET_MDIO        | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_ENET_MDC__ENET_MDC          | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TXC__ENET_RGMII_TXC   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD0__ENET_RGMII_TD0   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD1__ENET_RGMII_TD1   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD2__ENET_RGMII_TD2   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TD3__ENET_RGMII_TD3   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_ENET_REF_CLK__ENET_TX_CLK   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RXC__GPIO_6_30        | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD0__GPIO_6_25        | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD1__GPIO_6_27        | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD2__GPIO_6_28        | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RD3__GPIO_6_29        | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_RGMII_RX_CTL__GPIO_6_24     | MUX_PAD_CTRL(NO_PAD_CTRL),
+    MX6_PAD_EIM_D23__GPIO_3_23          | MUX_PAD_CTRL(NO_PAD_CTRL),            /* Chip nRST */
+    MX6_PAD_ENET_TX_EN__GPIO_1_28       | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t
+    const enet_pads2[]          =
+{
+    MX6_PAD_RGMII_RXC__ENET_RGMII_RXC   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD0__ENET_RGMII_RD0   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD1__ENET_RGMII_RD1   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD2__ENET_RGMII_RD2   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RD3__ENET_RGMII_RD3   | MUX_PAD_CTRL(ENET_PAD_CTRL),
+    MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_enet(void)
+{
+    gpio_direction_input(  IMX_GPIO_NR( 1, 28 ) );                              /* Used to read when the switch registers can be accessed */
+    gpio_direction_output( IMX_GPIO_NR( 3, 23 ), 0 );                           /* RGMII reset */
+    gpio_direction_output( IMX_GPIO_NR( 6, 30 ), 1 );                           /* RGMII RXC - P5_GTXCLK/AM_DIS-in - Marvell Auto-Media Detect capable PHYs are not attached */
+
+    /*
+        P5_MODE[2:0] = 001 - Port 5 is configured to be in RGMII mode
+        (1000 Mbps, full-duplex only)
+    */
+    gpio_direction_output( IMX_GPIO_NR( 6, 25 ), 1 );                           /* RGMII RD0 - P5_MODE[0] */
+    gpio_direction_output( IMX_GPIO_NR( 6, 27 ), 0 );                           /* RGMII RD1 - P5_MODE[1] */
+    gpio_direction_output( IMX_GPIO_NR( 6, 28 ), 0 );                           /* RGMII RD2 - P5_MODE[2] */
+
+    imx_iomux_v3_setup_multiple_pads( enet_pads1, ARRAY_SIZE( enet_pads1 ) );   /* Initializing TX pads   */
+    gpio_direction_output( IMX_GPIO_NR( 6, 24 ), 1 );                           /* RGMI RX CTL            */
+    udelay( 10 );                                                               /* Tsu delay - Configuration data valid prior to RESETn de-asserted */
+    gpio_set_value( IMX_GPIO_NR( 3, 23 ), 1 );                                  /* De-asserting RESETn    */
+    imx_iomux_v3_setup_multiple_pads( enet_pads2, ARRAY_SIZE( enet_pads2 ) );   /* Initializing RX pads   */
+}
+
+static int wait_for_switch(void)
+{
+    uint32_t
+        start;
+    start                       = get_timer(0);
+    while( gpio_get_value( IMX_GPIO_NR( 1, 28 ) ) )
+    {
+        if( get_timer( start ) > 3000 )
+        {
+            printf( "The ethernet switch doesn't come up\n" );
+            return -1;
+        }
+    }
+    return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_enet();
+    if( wait_for_switch() )
+    {
+        printf( "Impossible to access mv88e6123 chip registers.\n" );
+        return 0;
+    }
+	ret                         = cpu_eth_init(bis);
+	if( ret )
+    {
+		printf("FEC MXC: %s:failed\n", __func__);
+    }
+	return ret;
+}
+
+static struct mv88e61xx_config 
+    swcfg               = 
+{
+    .name               = "FEC",
+    .vlancfg            = MV88E61XX_VLANCFG_ROUTER,                             /* you can configure it as MV88E61XX_VLANCFG_SWITCH as well */
+    .rgmii_delay        = MV88E61XX_RGMII_DELAY_EN,
+    .led_init           = MV88E61XX_LED_INIT_EN,
+    .mdip               = MV88E61XX_MDIP_NOCHANGE,
+    .portstate          = MV88E61XX_PORTSTT_FORWARDING,
+    .cpuport            = ( 1 << 5 ),
+    .ports_enabled      = ( 1 << 5 ) | ( 1 << 1 ) | ( 1 << 0 ),
+};
+
+void reset_phy(void)
+{
+    mv88e61xx_switch_initialize( &swcfg );
+}
+
+/********************* i2c *********************/
+
+#define I2C_PAD_CTRL    (PAD_CTL_PUS_100K_UP |              \
+    PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |   \
+    PAD_CTL_ODE       | PAD_CTL_SRE_FAST )
+
+#define PC              MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+/* I2C1 (SILICA LVDS/Raspberry Pi expansion) */
+static struct i2c_pads_info
+    i2c1_pads_info      =
+{
+    .scl                =
+    {
+        .i2c_mode       = MX6_PAD_CSI0_DAT9__I2C1_SCL  | PC,
+        .gpio_mode      = MX6_PAD_CSI0_DAT9__GPIO_5_27 | PC,
+        .gp             = IMX_GPIO_NR( 5, 27 )
+    },
+    .sda                =
+    {
+        .i2c_mode       = MX6_PAD_CSI0_DAT8__I2C1_SDA  | PC,
+        .gpio_mode      = MX6_PAD_CSI0_DAT8__GPIO_5_26 | PC,
+        .gp             = IMX_GPIO_NR( 5, 26 )
+    }
+};
+
+/* I2C2 (PMIC and HDMI) */
+static struct i2c_pads_info
+    i2c2_pads_info      =
+{
+    .scl                =
+    {
+        .i2c_mode       = MX6_PAD_KEY_COL3__I2C2_SCL  | PC,
+        .gpio_mode      = MX6_PAD_KEY_COL3__GPIO_4_12 | PC,
+        .gp             = IMX_GPIO_NR( 4, 12 )
+    },
+    .sda                =
+    {
+        .i2c_mode       = MX6_PAD_KEY_ROW3__I2C2_SDA  | PC,
+        .gpio_mode      = MX6_PAD_KEY_ROW3__GPIO_4_13 | PC,
+        .gp             = IMX_GPIO_NR( 4, 13 )
+    }
+};
+
+/* I2C3 (miniPCIe) */
+static struct i2c_pads_info
+    i2c3_pads_info      =
+{
+    .scl                =
+    {
+        .i2c_mode       = MX6_PAD_GPIO_5__I2C3_SCL | PC,
+        .gpio_mode      = MX6_PAD_GPIO_5__GPIO_1_5 | PC,
+        .gp             = IMX_GPIO_NR( 1, 5 )
+    },
+    .sda                =
+    {
+        .i2c_mode       = MX6_PAD_GPIO_6__I2C3_SDA | PC,
+        .gpio_mode      = MX6_PAD_GPIO_6__GPIO_1_6 | PC,
+        .gp             = IMX_GPIO_NR( 1, 6 )
+    }
+};
+
+static void setup_tibidabo_i2cs(void)
+{
+    setup_i2c( 0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c1_pads_info );
+    setup_i2c( 1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c2_pads_info );
+    setup_i2c( 2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c3_pads_info );
+}
+
+/********************* display *********************/
+
+struct display_info_t 
+{
+    int     bus;
+    int     addr;
+    int     pixfmt;
+    int     (*detect)(struct display_info_t const *dev);
+    void    (*enable)(struct display_info_t const *dev);
+    struct  fb_videomode mode;
+};
+
+static int detect_hdmi(struct display_info_t const *dev)
+{
+    struct hdmi_regs
+        *hdmi               = (struct hdmi_regs *)HDMI_ARB_BASE_ADDR;
+    return readb(&hdmi->phy_stat0) & HDMI_DVI_STAT;
+}
+
+static void enable_hdmi(struct display_info_t const *dev)
+{
+    imx_enable_hdmi_phy();
+}
+
+static struct display_info_t
+    const displays[]        = 
+{
+    {
+        .bus                = -1,
+        .addr               = 0,
+        .pixfmt             = IPU_PIX_FMT_RGB24,
+        .detect             = detect_hdmi,
+        .enable             = enable_hdmi,
+        .mode               = 
+        {
+            .name           = "HDMI",
+            .refresh        = 60,
+            .xres           = 1024,
+            .yres           = 768,
+            .pixclock       = 15385,
+            .left_margin    = 220,
+            .right_margin   = 40,
+            .upper_margin   = 21,
+            .lower_margin   = 7,
+            .hsync_len      = 60,
+            .vsync_len      = 10,
+            .sync           = FB_SYNC_EXT,
+            .vmode          = FB_VMODE_NONINTERLACED
+        } 
+    },
+};
+
+int board_video_skip(void)
+{
+    int
+        i,
+        ret;
+    char
+        const *panel        = getenv("panel");
+    if( !panel )
+    {
+        for( i = 0; i < ARRAY_SIZE( displays ); i++ )
+        {            
+            struct display_info_t
+                const *dev  = displays + i;
+            if( dev->detect && dev->detect( dev ) )
+            {
+                panel       = dev->mode.name;
+                printf( "auto-detected panel %s\n", panel );
+                break;
+            }
+        }
+        if( !panel )
+        {
+            panel           = displays[0].mode.name;
+            printf( "No panel detected: default to %s\n", panel );
+        }
+    }
+    else
+    {
+        for( i = 0; i < ARRAY_SIZE( displays ); i++ )
+        {
+            if( !strcmp( panel, displays[ i ].mode.name ) )
+            {
+                break;
+            }
+        }
+    }
+    if( i < ARRAY_SIZE( displays ) )
+    {
+        ret                 = ipuv3_fb_init( &displays[ i ].mode, 0, displays[ i ].pixfmt );
+        if( !ret )
+        {
+            displays[ i ].enable( displays + i );
+            printf( "Display: %s (%ux%u)\n", displays[ i ].mode.name, displays[ i ].mode.xres, displays[ i ].mode.yres );
+        }
+        else
+        {
+            printf( "LCD %s cannot be configured: %d\n", displays[ i ].mode.name, ret );
+        }
+    }
+    else
+    {
+        printf( "unsupported panel %s\n", panel );
+        return -EINVAL;
+    }
+    return 0;
+}
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg
+        *mxc_ccm            = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc
+        *iomux              = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int
+        reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg                     = __raw_readl( &mxc_ccm->CCGR3 );
+	reg                     |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel( reg, &mxc_ccm->CCGR3 );
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg                     = readl( &mxc_ccm->cs2cdr );
+	reg                     &= ~( MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK );
+	reg                     |= ( 3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET ) | ( 3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET );
+	writel( reg, &mxc_ccm->cs2cdr );
+
+	reg                     = readl( &mxc_ccm->cscmr2 );
+	reg                     |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel( reg, &mxc_ccm->cscmr2 );
+
+	reg                     = readl( &mxc_ccm->chsccdr );
+	reg                     |= ( CHSCCDR_CLK_SEL_LDB_DI0 << MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET );
+	reg                     |= ( CHSCCDR_CLK_SEL_LDB_DI0 << MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET );
+	writel( reg, &mxc_ccm->chsccdr );
+
+	reg                     = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	                        | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	                        | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	                        | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	                        | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	                        | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	                        | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	                        | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	                        | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel( reg, &iomux->gpr[ 2 ] );
+
+	reg                     = readl( &iomux->gpr[ 3 ] );
+	reg                     = ( reg & ~( IOMUXC_GPR3_LVDS1_MUX_CTL_MASK | IOMUXC_GPR3_HDMI_MUX_CTL_MASK ) )
+	                        | ( IOMUXC_GPR3_MUX_SRC_IPU1_DI0 << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET );
+	writel( reg, &iomux->gpr[ 3 ] );
+}
+
+/********************* sata *********************/
+
+static int setup_sata(void)
+{
+	struct iomuxc_base_regs
+        *const iomuxc_regs  = (struct iomuxc_base_regs *) IOMUXC_BASE_ADDR;
+	int
+        ret                 = enable_sata_clock();
+	if( ret )
+    {
+		return ret;
+    }
+	clrsetbits_le32(
+                &iomuxc_regs->gpr[13],
+                IOMUXC_GPR13_SATA_MASK,
+                  IOMUXC_GPR13_SATA_PHY_8_RXEQ_3P0DB
+                | IOMUXC_GPR13_SATA_PHY_7_SATA2M
+                | IOMUXC_GPR13_SATA_SPEED_3G
+                | ( 3 << IOMUXC_GPR13_SATA_PHY_6_SHIFT )
+                | IOMUXC_GPR13_SATA_SATA_PHY_5_SS_DISABLED
+                | IOMUXC_GPR13_SATA_SATA_PHY_4_ATTEN_9_16
+                | IOMUXC_GPR13_SATA_PHY_3_TXBOOST_0P00_DB
+                | IOMUXC_GPR13_SATA_PHY_2_TX_1P104V
+                | IOMUXC_GPR13_SATA_PHY_1_SLOW
+            );
+
+	return 0;
+}
+
+/********************* information *********************/
+
+int checkboard(void)
+{
+    puts( "Board: Tibidabo\n" );
+    return 0;
+}
+
+int overwrite_console(void)
+{
+    return 1;
+}
+
+/********************* board init *********************/
+
+int dram_init(void)
+{
+    gd->ram_size                = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE); 
+    return 0;
+}
+
+int board_early_init_f(void)
+{
+    setup_iomux_uart();
+    setup_display();
+    return 0;
+}
+
+int board_init(void)
+{
+    gd->bd->bi_boot_params      = PHYS_SDRAM + 0x100;                       /* address of boot parameters */
+    setup_spi();
+    setup_tibidabo_i2cs();
+	setup_sata();
+    return 0;
+}
+
+int board_late_init(void)
+{
+    return 0;
+}
+
+int misc_init_r(void)
+{
+    return 0;
+}
diff --git a/board/architech/tibidabo/tibidabo.cfg b/board/architech/tibidabo/tibidabo.cfg
new file mode 100644
index 0000000..6a35c3a
--- /dev/null
+++ b/board/architech/tibidabo/tibidabo.cfg
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ * 
+ * Copyright (C) 2014 Avnet Emg
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+/* image version */
+IMAGE_VERSION   2
+
+/*
+ * Boot Device
+ */
+BOOT_FROM       spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "1066mhz_4x256mx16.cfg"
+#include "clocks.cfg"
diff --git a/configs/mx6qtibidabo_defconfig b/configs/mx6qtibidabo_defconfig
new file mode 100644
index 0000000..17a5854
--- /dev/null
+++ b/configs/mx6qtibidabo_defconfig
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX6=y
+CONFIG_TARGET_TIBIDABO=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/architech/tibidabo/tibidabo.cfg,MX6Q,DDR_MB=2048"
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_FLASH is not set
+CONFIG_SPI_FLASH=y
-- 
1.9.1

